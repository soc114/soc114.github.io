---
title: "Problem Set 3: Estimator and Bootstrap"
---

```{r, echo = FALSE, warnings = FALSE, message = FALSE}
library(tidyverse)
```

For this problem set, we will summarize wealth gaps using data from the 2022 Survey of Consumer Finances. We accessed these data via the [Berkeley Survey Documentation and Analysis](https://sda.berkeley.edu/sdaweb/analysis/?dataset=scfcomb2022) website and prepared the data file [scf_prepared.csv](../data/scf_prepared.csv) that you can load directly with the line of code below.

```{r, echo = FALSE, message = FALSE}
scf_prepared <- read_csv("../data/scf.csv") |>
  mutate(
    race = case_when(RACE == 1 ~ "White",
                     RACE == 2 ~ "Black",
                     RACE == 3 ~ "Hispanic",
                     RACE == 4 ~ "Asian",
                     RACE == 5 ~ "Other"),
    wealth = NETWORTH,
    wealth = ifelse(wealth < 10e3, 10e3, wealth)
  ) |>
  rename(weight = WGT) |>
  select(race, wealth, weight) |>
  write_csv("../data/scf_prepared.csv")
```

```{r, eval = F}
scf_prepared <- read_csv("https://soc114.github.io/data/scf_prepared.csv")
```

A row of these data corresponds to a household. These data contain three variables:

* `race` of the household respondent, coded in categories White, Black, Hispanic, Asian, and Other.
* `wealth` is the net worth of the household (assets minus debts), with households below \$10,000 recoded to a bottom-code of \$10,000
* `weight` is a sample weight (the inverse probability of sample inclusion)

Below we have info to get you started. The problem set questions start in the section [write an estimator function](#write-an-estimator-function).

## Info to get you started

This problem set will summarize wealth by the **geometric mean**, which is a summary statistic often used for distributions with long right tails. This summary statistic can be understood in steps:

* Transform $X$ to $\text{log}(X)$ to bring in the long right tail
* Summarize the transformed distribution by its mean
* Exponentiate the summary to move back to the scale of $X$ (since $e^{\text{log}(X)} = X$)

The figure below visualizes these steps to build intuition.

```{r, echo = F}
p1 <- tibble(p = seq(.01, .99, .01)) |>
  mutate(x = qlnorm(p),
         f = dlnorm(x)) |>
  ggplot(aes(x = x, ymin = 0, ymax = f)) +
  geom_ribbon(alpha = .2) +
  labs(
    title = "Begin with a distribution with a long right tail",
    x = "X",
    y = "Density"
  ) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank())
p2 <- tibble(p = seq(.01, .99, .01)) |>
  mutate(x = qnorm(p),
         f = dnorm(x)) |>
  ggplot(aes(x = x, ymin = 0, ymax = f)) +
  geom_ribbon(alpha = .2) +
  labs(
    title = "Transform to the distribution of log(X)",
    x = "log(X)",
    y = "Density"
  ) +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank())
p3 <- p2 +
  geom_vline(xintercept = 0, linetype = "dashed") +
  annotate(geom = "text", x = .2, y = 0, label = "mean\nof\nlog(X)", hjust = 0, vjust = -.5) +
  ggtitle("Summarize the log distribution by the mean")

p4 <- p1 +
  geom_vline(xintercept = 1, linetype = "dashed") +
  annotate(geom = "text", x = 1.2, y = 0, label = "exponentiated\nmean of log(X)", hjust = 0, vjust = -.5) +
  ggtitle("Re-exponentiate to produce the geometric mean")

gridExtra::grid.arrange(p1,p2,p3,p4, nrow = 4)
```

The code below applies these steps to the `scf_prepared` data to estimate the geometric mean of household wealth.

```{r}
scf_prepared |>
  # Creates a new variable log_wealth
  # which is the log of the wealth variable
  mutate(
    log_wealth = log(wealth)
  ) |>
  # Summarizes log wealth
  # by its weighted mean
  # (weight is the inverse probability
  # of sample inclusion)
  summarize(
    mean_log_wealth = weighted.mean(
      x = log_wealth, 
      w = weight
    )
  ) |>
  # Create a new variable geo_mean which
  # is the exponentiated mean of the log wealth
  mutate(
    geo_mean = exp(mean_log_wealth)
  ) |>
  # Pull the result out of the tibble
  # object to return a number
  pull(geo_mean)
```

Now it is your turn! The code above will be useful in the problem set parts below.

## 1. Write an estimator function

We want to use the code above many times, on many different samples. To do this, write a function called `geo_mean_estimator`. Your function should have one argument named `data`, which will be a `tibble` object in the format of `scf_prepared`. Your function should take `data` and calculate a summary statistic: the geometric mean.

You can use the code above within the body of your function. For help, see [R4DS Ch 25](https://r4ds.hadley.nz/functions.html).

## 2. Point estimate

Apply your `geo_mean_estimator` function with `data = scf_prepared`. Store the result in an object called `geo_mean_estimate`.

## 3. Bootstrap draws

Bootstrap your estimator 1,000 times. Store your bootstrap draws in an object named `bootstrap_draws`.

How you do this is up to you. There are at least two viable options:

a. You can initialize a vector `bootstrap_draws` as in class. Then write a for loop to populate it. See lecture slides on [for loops](https://soc114.github.io/slides/lec04_bootstrap/lec04_bootstrap.html#/how-to-write-a-for-loop).
b. You can use the `replicate(n, expr)` function where the `n` argument is the number of times to call the expression in the `expr` argument. See [this blog](https://www.r-bloggers.com/2023/07/the-replicate-function-in-r/).

Whatever method you use, you should use `slice_sample(prop = 1, replace = TRUE)` to resample the dataset with replacement for each bootstrap draw. See lecture slides on [how to generate bootstrap samples](https://soc114.github.io/slides/lec04_bootstrap/lec04_bootstrap.html#/how-to-generate-bootstrap-samples).

## 4. Confidence interval

Construct a 95\% confidence interval for the geometric mean by taking the 2.5 and 97.5 percentiles of the bootstrap draws. Store this in an object named `confidence_interval`.

## 5. Write a ratio estimator

Now write a new function named `ratio_estimator` that estimates a ratio:
$$
\frac{\text{geometric mean among white respondent households}}{\text{geometric mean among Black respondent households}}
$$
In words, this summary is how many dollars of wealth White households hold per dollar held by Black households, as summarized by the geometric mean.

You might consider using the `geo_mean_estimator()` function you already wrote within your `ratio_estimator()` function.

## 6. Point estimate for the ratio

Apply `ratio_estimator` with `data = scf_prepared` to produce a point estimate. Store the result in `ratio_estimate`.

## 7. Bootstrap the ratio estimator

Bootstrap the ratio estimator with 1,000 draws. Store the bootstrap estimates in an object called `ratio_bootstrap`.

## 8. Confidence interval for the ratio

Construct a 95\% confidence interval for the ratio by taking the 2.5 and 97.5 percentiles of the bootstrap draws. Store this in an object named `ratio_confidence_interval`.


