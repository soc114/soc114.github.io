{
  "hash": "dc9e25132fecf0c7a7981b9916a10764",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Nonparametric estimation\"\n---\n\n\n\n\n> If time allows, this will be covered on Feb 4. Here are [slides]([slides](../slides/lec09b_nonparametric_estimation/lec09b_nonparametric_estimation.pdf)\n\nUnder the assumption of conditional exchangeability given a sufficient adjustment set $\\vec{X}$, the average causal effect within subgroups defined by $\\vec{X}$ is identified by the difference in means across the treatment $A$ within this subgroup.\n\nThis page walks through how to estimate that difference in means and (optinally) re-aggregate the conditional average causal effects to average causal effect estimates. We illustrate in a simple case represented by the DAG below.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](nonparametric_estimation_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\nIn our illustration, the treatment `a` is binary and the outcome `y` is numeric. The confounder `x` is a sufficient adjustment set and takes the value 0, 1, or 2.\n\nYou can simulate a dataset of 1,000 observations by running the code below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nsimulated <- tibble(id = 1:1000) |>\n  mutate(\n    x = rbinom(n(), 2, .5),\n    pi = case_when(\n      x == 0 ~ .3,\n      x == 1 ~ .5,\n      x == 2 ~ .8\n    ),\n    a = rbinom(n(), 1, pi),\n    y = rnorm(n(), mean = x*a),\n    # For illustration, we include a sampling weight variable\n    # because in real settings there may be sampling weights\n    sampling_weight = 1\n  )\n```\n:::\n\n\n\n\n## Estimate CATEs by subgroup means\n\nTo estimate the conditional average effect, we first group the data by the confounder `x` and treatment `a`. By conditional exchangeability, the rows with `a == TRUE` and the rows with `a == FALSE` are each a simple random sample of all rows within the subgroup defined by `x`, so we can estimate the mean outcome $\\E(Y^a\\mid X = x)$ by the subgroup sample mean, $\\E(Y\\mid A = a, X = x)$.\n\n$$\n\\hat{\\text{E}}\\left(Y^a\\mid X = x\\right) = \\underbrace{\\frac{\\sum_{i:X_i=x,A_i=a}Y_i}{n_{x,a}}}_{\\substack{\\text{Sample mean}\\\\\\text{in subgroup}\\\\X = x, A = a}}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage_potential_outcomes <- simulated |>\n  # Group by confounders and treatment\n  group_by(x,a) |>\n  # Summarize weighted mean of Y, weighted by sampling weights\n  summarize(\n    mean_y = weighted.mean(y, w = sampling_weight), \n    .groups = \"drop\"\n  ) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n      x     a  mean_y\n  <int> <int>   <dbl>\n1     0     0 -0.0478\n2     0     1  0.168 \n3     1     0  0.0417\n4     1     1  1.04  \n5     2     0 -0.0106\n6     2     1  1.93  \n```\n\n\n:::\n:::\n\n\n\n\nAs expected, the code above produces estimates for the mean of `y` within subgroups defined by `x` and `a`. The conditional average causal effect is difference in `y` across values of `a`, within subgroups defined by `x`. To take this difference, we pivot wider.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncate <- average_potential_outcomes |>\n  # Pivot wider and difference over A to estimate CATE\n  pivot_wider(\n    names_from = a, \n    names_prefix = \"mean_y\", \n    values_from = \"mean_y\"\n  ) |>\n  mutate(cate = mean_y1 - mean_y0) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x mean_y0 mean_y1  cate\n  <int>   <dbl>   <dbl> <dbl>\n1     0 -0.0478   0.168 0.216\n2     1  0.0417   1.04  0.994\n3     2 -0.0106   1.93  1.94 \n```\n\n\n:::\n:::\n\n\n\n\nAs expected, the code above estimates the Conditional Average Treatment Effect (CATE) within each population subgroup defined by the pre-treatment variable `x`.\n\n## Re-aggregating to ATE\n\nTo determine the overall average treatment effect, we can re-aggregated the CATE estimates weighted by the size of each stratum: how many people have `x == 1`, `x == 2`, and `x == 3`. First, determine the size of each stratum.\n\n$$\n\\hat{\\text{P}}\\left(X = x\\right) = \\frac{1}{n}\\sum_i \\mathbb{I}(X_i = x)\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstratum_sizes <- simulated |>\n  # Count sum of sampling weight in each stratum\n  count(x, wt = sampling_weight) |>\n  # Convert count to a proportion of the population\n  mutate(stratum_size = n / sum(n)) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n      x     n stratum_size\n  <int> <dbl>        <dbl>\n1     0   248        0.248\n2     1   493        0.493\n3     2   259        0.259\n```\n\n\n:::\n:::\n\n\n\n\nThen merge and take the weighted mean of CATE over the strata.\n\n$$\n\\hat{\\text{E}}\\left(Y^1-Y^0\\right) = \\sum_x \\hat{\\text{P}}(X = x)\\left[\\hat{\\text{E}}\\left(Y^1\\mid X = x\\right) - \\hat{\\text{E}}\\left(Y^0\\mid X = x\\right)\\right]\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nate <- cate |>\n  left_join(stratum_sizes, by = join_by(x)) |>\n  summarize(ate = weighted.mean(cate, w = stratum_size)) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n    ate\n  <dbl>\n1  1.04\n```\n\n\n:::\n:::\n\n\n\n\n## Estimate by treatment weights\n\nOne can equivalently take a sampling view of causal inference. When I observe a unit $i$ with outcome $Y_i = Y_i^{A_i}$, the probability of observing this outcome is the product of the probability that the unit was sampled multiplied by the probability that the unit received treatment value $A_i$, conditional on confounders. Just as one generates sampling weights for descriptive population inference by the inverse of the probability of sample inclusion, one can generate inverse probability of treatment weights for causal inference. The full weight for each unit $i$ is then the product of these two weights:\n\n$$\nw_i = \\text{SamplingWeight}_i\\times \\frac{1}{\\text{P}(A_i\\mid X_i)}\n$$\n\nThe code below constructs these weights.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_weighted <- simulated |>\n  # Within confounder subgroups, determine the probability\n  # of the observed treatment\n  group_by(x) |>\n  mutate(probability_of_a = case_when(\n    # For treated units, proportion treated\n    a == 1 ~ mean(a),\n    # For untreated units, proportion untreated\n    a == 0 ~ mean(1 - a)\n  )) |>\n  # Calculate the total weight as the product\n  # of the sampling weight and the inverse probability of treatment\n  mutate(\n    total_weight = sampling_weight * (1 / probability_of_a)\n  ) |>\n  ungroup() |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000 × 8\n      id     x    pi     a        y sampling_weight probability_of_a\n   <int> <int> <dbl> <int>    <dbl>           <dbl>            <dbl>\n 1     1     0   0.3     0 -0.584                 1            0.714\n 2     2     0   0.3     0 -1.52                  1            0.714\n 3     3     0   0.3     0 -0.00455               1            0.714\n 4     4     1   0.5     1  0.841                 1            0.505\n 5     5     1   0.5     1  1.68                  1            0.505\n 6     6     0   0.3     1  0.244                 1            0.286\n 7     7     1   0.5     1 -0.0235                1            0.505\n 8     8     1   0.5     0  0.732                 1            0.495\n 9     9     1   0.5     0  0.0467                1            0.495\n10    10     1   0.5     0  1.82                  1            0.495\n# ℹ 990 more rows\n# ℹ 1 more variable: total_weight <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nOnce we have weights, we can directly estimate the Average Treatment Effect (ATE) by the mean difference in the weighted average outcomes in each treatment group,\n\n$$\n\\hat{\\text{E}}(Y^a) = \\frac{\\sum_{i:A_i=a} w_i Y_i}{\\sum_{i:A_i=a}w_i}\n$$\nand report the difference in the estimated $\\hat{E}(Y^1)$ and $\\hat{E}(Y^0)$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_weighted |>\n  # Summarize weighted mean outcomes within treatment groups\n  group_by(a) |>\n  summarize(\n    estimate = weighted.mean(\n      y, \n      w = total_weight\n    )\n  ) |>\n  # Difference across treatment groups and estimate the ATE\n  pivot_wider(names_from = a, names_prefix = \"mean_y\", values_from = estimate) |>\n  mutate(ate = mean_y1 - mean_y0) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_y0 mean_y1   ate\n    <dbl>   <dbl> <dbl>\n1 0.00594    1.05  1.04\n```\n\n\n:::\n:::\n\n\n\n\n## Comparing the two estimates\n\nAbove, we illustrated two strategies to estimate the Average Treatment Effect.\n\n1. Estimate the CATE by subgroup means of $Y$ within $X$ and $A$, then aggregate across strata weighted by size.\n2. Estimate the probability of treatment $A$ given $X$, then estimate the ATE by a weighted mean.\n\nYou may notice that the estimates by the two approaches are **mathematically identical**. At least under nonparametric estimation, one can show that these two estimators are two different ways of thinking about the exact same estimation process.\n\n## Concluding thoughts\n\nNonparametric estimation is worth knowing because of its simplicity: estimate the conditional average causal effect within subgroups by taking the difference in mean outcomes within subgroups. However, nonparametric estimation only works in practice when the confounding variables take only a few discrete values (in this example, `x` was always 0, 1, or 2). In realistic settings, there are often many confounding variables that take many values each. For this reason, causal effects are most often estimated in practice by the model-based methods that we will learn next.\n\n",
    "supporting": [
      "nonparametric_estimation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}