{
  "hash": "2be94f61c8db3be32d205f6680c91230",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Problem Set 3: Estimator and Bootstrap\"\n---\n\n\n::: {.cell warnings='false'}\n\n:::\n\n\nFor this problem set, we will summarize wealth gaps using data from the 2022 Survey of Consumer Finances. We accessed these data via the [Berkeley Survey Documentation and Analysis](https://sda.berkeley.edu/sdaweb/analysis/?dataset=scfcomb2022) website and prepared the data file [scf_prepared.csv](../data/scf_prepared.csv) that you can load directly with the line of code below.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscf_prepared <- read_csv(\"https://soc114.github.io/data/scf_prepared.csv\")\n```\n:::\n\n\nA row of these data corresponds to a household. These data contain three variables:\n\n* `race` of the household respondent, coded in categories White, Black, Hispanic, Asian, and Other.\n* `wealth` is the net worth of the household (assets minus debts), with households below \\$10,000 recoded to a bottom-code of \\$10,000\n* `weight` is a sample weight (the inverse probability of sample inclusion)\n\nBelow we have info to get you started. The problem set questions start in the section [write an estimator function](#write-an-estimator-function).\n\n## Info to get you started\n\nThis problem set will summarize wealth by the **geometric mean**, which is a summary statistic often used for distributions with long right tails. This summary statistic can be understood in steps:\n\n* Transform $X$ to $\\text{log}(X)$ to bring in the long right tail\n* Summarize the transformed distribution by its mean\n* Exponentiate the summary to move back to the scale of $X$ (since $e^{\\text{log}(X)} = X$)\n\nThe figure below visualizes these steps to build intuition.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](pset3_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThe code below applies these steps to the `scf_prepared` data to estimate the geometric mean of household wealth.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscf_prepared |>\n  # Creates a new variable log_wealth\n  # which is the log of the wealth variable\n  mutate(\n    log_wealth = log(wealth)\n  ) |>\n  # Summarizes log wealth\n  # by its weighted mean\n  # (weight is the inverse probability\n  # of sample inclusion)\n  summarize(\n    mean_log_wealth = weighted.mean(\n      x = log_wealth, \n      w = weight\n    )\n  ) |>\n  # Create a new variable geo_mean which\n  # is the exponentiated mean of the log wealth\n  mutate(\n    geo_mean = exp(mean_log_wealth)\n  ) |>\n  # Pull the result out of the tibble\n  # object to return a number\n  pull(geo_mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 161195.7\n```\n\n\n:::\n:::\n\n\nNow it is your turn! The code above will be useful in the problem set parts below.\n\n## 1. Write an estimator function\n\nWe want to use the code above many times, on many different samples. To do this, write a function called `geo_mean_estimator`. Your function should have one argument named `data`, which will be a `tibble` object in the format of `scf_prepared`. Your function should take `data` and calculate a summary statistic: the geometric mean.\n\nYou can use the code above within the body of your function. For help, see [R4DS Ch 25](https://r4ds.hadley.nz/functions.html).\n\n## 2. Point estimate\n\nApply your `geo_mean_estimator` function with `data = scf_prepared`. Store the result in an object called `geo_mean_estimate`.\n\n## 3. Bootstrap draws\n\nBootstrap your estimator 1,000 times. Store your bootstrap draws in an object named `bootstrap_draws`.\n\nHow you do this is up to you. There are at least two viable options:\n\na. You can initialize a vector `bootstrap_draws` as in class. Then write a for loop to populate it. See lecture slides on [for loops](https://soc114.github.io/slides/lec04_bootstrap/lec04_bootstrap.html#/how-to-write-a-for-loop).\nb. You can use the `replicate(n, expr)` function where the `n` argument is the number of times to call the expression in the `expr` argument. See [this blog](https://www.r-bloggers.com/2023/07/the-replicate-function-in-r/).\n\nWhatever method you use, you should use `slice_sample(prop = 1, replace = TRUE)` to resample the dataset with replacement for each bootstrap draw. See lecture slides on [how to generate bootstrap samples](https://soc114.github.io/slides/lec04_bootstrap/lec04_bootstrap.html#/how-to-generate-bootstrap-samples).\n\n## 4. Confidence interval\n\nConstruct a 95\\% confidence interval for the geometric mean by taking the 2.5 and 97.5 percentiles of the bootstrap draws. Store this in an object named `confidence_interval`.\n\n## 5. Write a ratio estimator\n\nNow write a new function named `ratio_estimator` that estimates a ratio:\n$$\n\\frac{\\text{geometric mean among white respondent households}}{\\text{geometric mean among Black respondent households}}\n$$\nIn words, this summary is how many dollars of wealth White households hold per dollar held by Black households, as summarized by the geometric mean.\n\nYou might consider using the `geo_mean_estimator()` function you already wrote within your `ratio_estimator()` function.\n\n## 6. Point estimate for the ratio\n\nApply `ratio_estimator` with `data = scf_prepared` to produce a point estimate. Store the result in `ratio_estimate`.\n\n## 7. Bootstrap the ratio estimator\n\nBootstrap the ratio estimator with 1,000 draws. Store the bootstrap estimates in an object called `ratio_bootstrap`.\n\n## 8. Confidence interval for the ratio\n\nConstruct a 95\\% confidence interval for the ratio by taking the 2.5 and 97.5 percentiles of the bootstrap draws. Store this in an object named `ratio_confidence_interval`.\n\n\n",
    "supporting": [
      "pset3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}