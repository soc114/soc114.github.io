{
  "hash": "411430c37e0a4c78df4d266704dd4602",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Models for causal inference\"\nformat: pdf\n---\n\n\n\n\n<!-- notes: this was tricky to teach because most of the class has never used OLS with interaction terms before. In the future, need to explain OLS with interactions with a simple example, similar to how I might explain trees with a simple example. Updated: I changed from one model with a * x interactions to two models, one with a = 0 and one with a = 1. Replaced content on website and moved old content to outtakes. Will try teaching this without slides and see how it goes. -->\n\n> Here are slides on [outcome modeling](../slides/lec12_causal_outcome_model/lec12_causal_outcome_model.pdf) and [treatment modeling](../slides/ipw/ipw.pdf).\n\nModels are useful when we need subgroup summaries but we do not observe very many units in each subgroup. This situation is common in causal inference: we assume that $\\vec{X}$ is a sufficient adjustment set so that conditional exchangeability holds, and this allows us to identify the causal quantity $\\text{E}(Y^a\\mid \\vec{X} = \\vec{x})$ by the statistical quantity $\\text{E}(Y\\mid A = a, \\vec{X} = \\vec{x})$. But that empirical quantity---the subgroup mean among those with treatment value $a$ and adjustment set value $\\vec{x}$---may be the mean of a subgroup that is unpopulated. This is especially true in practice because the adjustment set $\\vec{X}$ is often most plausible when it includes many variables, leading to a curse of dimensionality and small subgroup sample sizes. For this reason, causal inference approaches that adjust for measured variables often require us to estimate the means in many subgroups that are sparsely populated.\n\nThis page introduces outcome models for causal inference. To run the code on this page, you will need the tidyverse.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n## Motivating example\n\nTo what extent does completing a four-year college degree by age 25 increase the probability of having a spouse or residential partner with a four-year college degree at age 35, among the population of U.S. residents who were ages 12--16 at the end of 1996?\n\nWe used this example on the [Why Model?](why_model.qmd) page and will continue with it here. For those jumping in on this page, here is a refresher.\n\nThis causal question draws on questions in sociology and demography about assortative mating: the tendency of people with high education, income, or status to form households together^[For reviews, see [Mare 1991](https://doi.org/10.2307/2095670) and [Schwartz 2013](https://doi.org/10.1146/annurev-soc-071312-145544).]. One reason to care about assortative mating is that it can contribute to inequality across households: if people with high earnings potential form households together, then income inequality across households will be greater than it would be if people formed households randomly.\n\nOur question is causal: to what extent is the probability of marrying a four-year college graduate higher if one were hypothetically to finish a four-year degree, versus if that same person were hypothetically to not finish a college degree? But in data that exist in the world, we see only one of these two potential outcomes. The people for whom we see the outcome under a college degree are systematically different from those for whom we see the outcome under no degree: college graduates come from families with higher incomes, higher wealth, and higher parental education, for example. All of these factors may directly shape the probability of marrying a college graduate even in the absence of college. Thus, it will be important to adjust for a set of measured confounders, represented by $\\vec{X}$ in our DAG.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](models_for_causal_files/figure-pdf/unnamed-chunk-2-1.pdf)\n:::\n:::\n\n\n\n\nBy adjusting for the variables $\\vec{X}$, we block all non-causal paths between the treatment $A$ and the outcome $Y$ in the DAG. If this DAG is correct, then conditional exchangeability holds with this adjustment set: $\\{Y^1,Y^0\\}\\indep A \\mid\\vec{X}$.\n\nTo estimate, we use data from the [National Longitudinal Survey of Youth 1997](https://www.bls.gov/nls/nlsy97.htm), a probability sample of U.S. resident children who were ages 12--16 on Dec 31, 1996. The study followed these children and interviewed them every year through 2011 and then every other year after that.\n\nWe will analyze a simulated version of these data ([nlsy97_simulated.csv](../data/nlsy97_simulated.csv)), which you can access with this line of code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_cases <- read_csv(\"https://soc114.github.io/data/nlsy97_simulated.csv\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Expand to learn how to get the actual data\n\nTo access the actual data, you would need to [register](https://nlsinfo.org/investigator/pages/register) for an account, [log in](https://nlsinfo.org/investigator/pages/login), upload the [nlsy97.NLSY97](../code/nlsy97.NLSY97) tagset that identifies our variables, and then download. Unzip the folder and put the contents in a directory on your computer. Then run our code file [prepare_nlsy97.R](../code/prepare_nlsy97.R) in that folder. This will produce a new file `d.RDS`, contains the data. You could analyze that file. In the interest of transparency, we wrote the code [nlsy97_simulated.R](../data/nlsy97_simulated.R) to convert these real data to simulated data that we can share.\n:::\n\nThe data contain several variables\n\n* `id` is an individual identifier for each person\n* `a` is the treatment, containing the respondent's education coded `treated` if the respondent completed a four-year college degree and `untreated` if not.\n* `y` is the outcome: `TRUE` if has a spouse or residential partner at age 35 who holds a college degree, and `FALSE` if no spouse or partner or if the spouse or partner at age 35 does not have a degree.\n* There are several pre-treatment variables\n     * `sex` is coded `Female` and `Male`\n     * `race` is race/ethnicity and is coded `Hispanic`, `Non-Hispanic Black`, and `Non-Hispanic Non-Black`.\n     * `mom_educ` is the respondent's mother's education as reported in 1997. It takes the value `No mom` if the child had no residential mother in 1997, and otherwise is coded with her education: `< HS`, `High school`, `Some college`, or `College`.\n     * `dad_educ` is the respondent's father's education as reported in 1997. It takes the value `No dad` if the child had no residential father in 1997, and otherwise is coded with his education: `< HS`, `High school`, `Some college`, or `College`.\n     * `log_parent_income` is the log of gross household income in 1997\n     * `log_parent_wealth` is the log of household net worth in 1997\n     * `test_percentile` is the respondent's percentile score on a test of math and verbal skills administered in 1999 (the Armed Services Vocational Aptitude Battery).\n     \nWhen values are missing, we have replcaed them with predicted values. In the simulated data, no row represents a real person because values have been drawn randomly from a probability distribution designed to mimic what exists in the real data. As discussed above, we did this in order to share the file with you by a download on this website.\n\n## Outcome modeling\n\nBecause the causal effect of `A` on `Y` is identified by adjusting for the confounders, we can estimate by outcome modeling. There are three general steps.\n\n1) Model $E(Y\\mid A, \\vec{X})$, the conditional mean of $Y$ given the treatment and confounders\n2) Predict potential outcomes\n     * Predict $Y^1$ for every unit\n     * Predict $Y^0$ for every unit\n3) Aggregate to the average causal effect\n\n### With one confounder\n\nWe first illustrate the steps as though there were only one confounding variable: test percentile. The first step is to create a data object containing only the treated observations and a data object containing only the untreated observations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuntreated_cases <- all_cases |> filter(a == \"untreated\")\ntreated_cases <- all_cases |> filter(a == \"treated\")\n```\n:::\n\n\n\n\nWe use the untreated cases to estimate a model for $Y^0$ as a function of $X$. If our data include sampling weights, then we weight this model by the sampling weights.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_for_y0 <- lm(\n  y ~ test_percentile, \n  data = untreated_cases,\n  weights = sampling_weight\n)\n```\n:::\n\n\n\n\nWhat happened above? The `lm()` function estimates a linear model, which is stored in the `model` object. The first argument is the model formula, which defines the function by which we model the conditional mean of the outcome given the predictors. The second argument is the data we use to learn the model.\n\nIn math, this model could be written as,\n$$\n\\text{E}(Y\\mid A = 0, X) = \\alpha_0 + \\beta_0 X\n$$\nwhere $\\alpha_0$ is an intercept and $\\beta_0$ is a slope. Here, we are using the 0 subscripts to denote that these are estimates among the untreated.\n\nWe can likewise use the treated cases to estimate a model for $Y^1$ as a function of $X$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_for_y1 <- lm(\n  y ~ test_percentile, \n  data = treated_cases,\n  weights = sampling_weight\n)\n```\n:::\n\n\n\n\nwhich could be written in math as follows.\n\n$$\n\\text{E}(Y\\mid A = 1, X) = \\alpha_1 + \\beta_1 X\n$$\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](models_for_causal_files/figure-pdf/unnamed-chunk-8-1.pdf)\n:::\n:::\n\n\n\n\nWe can now use our models to predict for our target population. For the average treatment effect, the target population is all cases. For every case, we can predict probabilities under treatment and under control.\n\n$$\n\\begin{aligned}\n\\hat{Y}_1 &= \\hat{\\text{E}}(Y\\mid A = 1, X) = \\hat\\alpha_1 + \\hat\\beta_1 X \\\\\n\\hat{Y}_0 &= \\hat{\\text{E}}(Y\\mid A = 0, X) = \\hat\\alpha_0 + \\hat\\beta_0 X \\\\\n\\end{aligned}\n$$\n\nIn code, we make those predictions with the `predict()` function, storing them in new variables `yhat1` and `yhat0`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes <- all_cases |>\n  mutate(\n    yhat1 = predict(model_for_y1, newdata = all_cases),\n    yhat0 = predict(model_for_y0, newdata = all_cases),\n    effect = yhat1 - yhat0\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 6\n     id sampling_weight a         yhat1  yhat0 effect\n  <dbl>           <dbl> <chr>     <dbl>  <dbl>  <dbl>\n1     1           0.989 untreated 0.403 0.171   0.232\n2     2           0.999 treated   0.645 0.317   0.328\n3     3           0.967 untreated 0.283 0.0990  0.184\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\nVisually, the target population is all the gray points: everyone regardless of treatment. For each point, we predict the outcome probability under treatment and under no treatment.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](models_for_causal_files/figure-pdf/unnamed-chunk-11-1.pdf)\n:::\n:::\n\n\n\n\nThe average treatment effect (ATE) is the weighted average of the case-specific effect estimates, weighted by sampling weights.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes |>\n  summarize(ate = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n    ate\n  <dbl>\n1 0.224\n```\n\n\n:::\n:::\n\n\n\n\nWe could also estimate among any subgroup, for example the average treatment effect among the treated and among the untreated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes |>\n  group_by(a) |>\n  summarize(conditional_average_effect = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  a         conditional_average_effect\n  <chr>                          <dbl>\n1 treated                        0.278\n2 untreated                      0.211\n```\n\n\n:::\n:::\n\n\n\n\n### With many confounders\n\nOutcome modeling generalizes easily from one confounder to many confounders. The only change is to include more confounders in the outcome model formulas.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_for_y0 <- lm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  data = untreated_cases,\n  weights = sampling_weight\n)\nmodel_for_y1 <- lm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  data = treated_cases,\n  weights = sampling_weight\n)\n```\n:::\n\n\n\n\nOtherwise, outcome modeling with many confounders follows the same process. If our goal is to estimate the average treatment effect in `all_cases`,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes <- all_cases |>\n  mutate(\n    yhat1 = predict(model_for_y1, newdata = all_cases),\n    yhat0 = predict(model_for_y0, newdata = all_cases),\n    effect = yhat1 - yhat0\n  ) |>\n  select(id, sampling_weight, a, yhat1, yhat0, effect) |>\n  print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 6\n     id sampling_weight a         yhat1   yhat0 effect\n  <dbl>           <dbl> <chr>     <dbl>   <dbl>  <dbl>\n1     1           0.989 untreated 0.255  0.0889  0.166\n2     2           0.999 treated   0.727  0.441   0.285\n3     3           0.967 untreated 0.149 -0.0139  0.163\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe average treatment effect (ATE) is the weighted average of the case-specific effect estimates, weighted by sampling weights.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes |>\n  summarize(ate = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n    ate\n  <dbl>\n1 0.199\n```\n\n\n:::\n:::\n\n\n\n\nWe could also estimate among any subgroup, for example the average treatment effect among the treated and among the untreated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_potential_outcomes |>\n  group_by(a) |>\n  summarize(conditional_average_effect = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  a         conditional_average_effect\n  <chr>                          <dbl>\n1 treated                        0.253\n2 untreated                      0.187\n```\n\n\n:::\n:::\n\n\n\n\n### Generalizing to logistic regression\n\nIn the illustration above, we might be concerned that our outcome is binary (taking values 0 or 1) and yet the predictions are sometimes below 0 or above 1.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](models_for_causal_files/figure-pdf/unnamed-chunk-18-1.pdf)\n:::\n:::\n\n\n\n\nBoth models are predicting that some people have **negative** probabilities of having a college-degree-holding spouse or partner! We might want to solve this by estimating logistic regression models. We do this with the `glm()` function with the argument `family = binomial`.\n\n> If logistic regression is new to you, see the bottom of [What is a model?](what_is_a_model.qmd).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_model_for_y0 <- glm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  family = binomial,\n  data = untreated_cases,\n  weights = sampling_weight\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n```\n\n\n:::\n\n```{.r .cell-code}\nlogistic_model_for_y1 <- glm(\n  y ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile, \n  family = binomial,\n  data = treated_cases,\n  weights = sampling_weight\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in eval(family$initialize): non-integer #successes in a binomial glm!\n```\n\n\n:::\n:::\n\n\n\n\nThese models return a warning that there is a non-integer number of successes. This is normal and not a concern when estimating logistic regression models with weights.\n\nJust as with linear regression, we can use our logistic regression to predict potential outcome values. When making predictions, it is important to use the `type = \"response\"` argument to predict the probability of $Y = 1$ instead of the log odds of $Y = 1$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_predicted_potential_outcomes <- all_cases |>\n  mutate(\n    yhat1 = predict(\n      logistic_model_for_y1, \n      newdata = all_cases, \n      type = \"response\"\n    ),\n    yhat0 = predict(\n      logistic_model_for_y0, \n      newdata = all_cases, \n      type = \"response\"\n    ),\n    effect = yhat1 - yhat0\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 6\n     id sampling_weight a         yhat1  yhat0 effect\n  <dbl>           <dbl> <chr>     <dbl>  <dbl>  <dbl>\n1     1           0.989 untreated 0.254 0.0861  0.168\n2     2           0.999 treated   0.726 0.562   0.164\n3     3           0.967 untreated 0.177 0.0261  0.151\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\nIn math, we can see why the `type = \"response\"` is needed. By default, using `predict()` after logistic regression will predict the log odds of the outcome. For example for the outcome under treatment:\n\n$$\n\\log\\left(\\frac{\\hat{\\text{P}}(Y = 1\\mid A = 1, X)}{1 - \\hat{\\text{P}}(Y = 1\\mid A = 1, X)}\\right) = \\hat\\alpha_1 + \\hat\\beta_1 X\n$$\n\nBut we really estimated the model to estimate $\\hat{P}(Y = 1\\mid A = 1, X)$, not a complicated function of that quantity. By typing `type = \"response\"`, you tell R to invert the logit function and return predicted probabilities.\n\n$$\n\\hat{\\text{P}}(Y = 1\\mid A = 1, X) = \\frac{e^{\\hat\\alpha_1 + \\hat\\beta_1 X}}{1 + e^{\\hat\\alpha_1 + \\hat\\beta_1 X}}\n$$\n\nBy using `type = \"response\"`, you can think about the probabilities on the left side of the equation and not the math on the right side of the equation. We can visualize that with logistic regression, all predicted probabilities fall within the [0,1] range.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](models_for_causal_files/figure-pdf/unnamed-chunk-22-1.pdf)\n:::\n:::\n\n\n\n\nExactly as with linear regression, we can aggregate the predicted potential outcomes to estimate the average treatment effect over all cases (ATT),\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_ate_estimate <- logistic_predicted_potential_outcomes |>\n  summarize(ate = weighted.mean(effect, w = sampling_weight)) |>\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n    ate\n  <dbl>\n1 0.204\n```\n\n\n:::\n:::\n\n\n\n\nor among those who were factually treated or untreated,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogistic_predicted_potential_outcomes |>\n  group_by(a) |>\n  summarize(conditional_average_effect = weighted.mean(effect, w = sampling_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  a         conditional_average_effect\n  <chr>                          <dbl>\n1 treated                        0.240\n2 untreated                      0.195\n```\n\n\n:::\n:::\n\n\n\n\nor among any subpopulation by grouping by any confounding variables.\n\nWe estimate that completing college increases the probability of having a college-educated by 0.204. This causal conclusion relies both on our causal assumptions (the DAG) and our statistical assumptions (the chosen model).\n\n## Treatment modeling\n\nInstead of modeling the outcome, another way of using models for causal inference is to model the probability of treatment assignment. This approach is more analogous to sampling from a population.\n\nIn a probability sample, we observe the outcome $Y_i$ for any sampled unit $(S_i=1)$ which is seen with some probability of sampling, $P(S=1\\mid\\vec{X} = \\vec{x}_i)$ that may differ across subgroups with different values of some variables $\\vec{X}$. As discussed in population sampling, the sampling weight is the inverse of these probabilities. A person who is sampled with a 20\\% probability represents 1 / .2 = 5 people in the population (the other 4 being unsampled).\n\nIn a conditionally randomized experiment, we observe the outcome under treatment $Y_i^1$ for any treated unit $A_i=1$, which might be assigned with some probability $P(A_i=1\\mid\\vec{X} = \\vec{x}_i)$ that differs across subgroups defined by an adjustment set $\\vec{X}$. In a conditionally randomized experiment, these probabilities are known and the overall expected outcome under treatment $\\text{E}(Y^1)$ can be estimated by the average of the observed outcomes under treatment, weighted by the inverse probability of being treated. A treated unit who had a 20\\% probability of being treated represents 1 / .2 = 5 people (the other 4 being untreated).\n\nIn an observational study, we don't know the probability of being treated given the variables in our sufficient adjustment set. We need to model that probability. There are three general steps.\n\n1) Model treatment probabilities given an adjustment set\n2) Construct a weight for each unit\n3) Estimate by weighted means within each treatment group\n\n### 1) Model treatment probabilities\n\nOne way to model the probability of treatment is with logistic regression. If logistic regression is new to you, see the bottom of [What is a model?](what_is_a_model.qmd).\n\n$$\n\\log\\left(\\frac{P(A = 1 \\mid\\vec{X})}{1-P(A = 1\\mid\\vec{X})}\\right) = \\alpha + \\vec{X}'\\vec\\beta\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment_model <- glm(\n  I(a == \"treated\") ~ sex + race + mom_educ + dad_educ + log_parent_income +\n    log_parent_wealth + test_percentile,\n  family = binomial,\n  data = all_cases\n)\n```\n:::\n\n\n\n\nFor every unit, we can then predict the probability of being treated given the adjustment set.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_treatment_probabilities <- all_cases |>\n  mutate(p_treated = predict(treatment_model, type = \"response\")) |>\n  select(id, a, y, p_treated)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 4\n     id a         y     p_treated\n  <dbl> <chr>     <lgl>     <dbl>\n1     1 untreated FALSE    0.0720\n2     2 treated   TRUE     0.777 \n3     3 untreated FALSE    0.0318\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe `type = \"response\"` argument is essential, because this tells R to predict the probability of treatment instead of the log odds of treatment.\n\n### 2) Construct weights\n\nFor each unit, we can construct a weight that is the inverse probability of that unit's treatment assignment. Recall that if a unit is treated and had a 0.2 probability of treatment, then we could think of this unit as representing 1 / 0.2 = 5 units: itself and 4 others like it who were not treated. The weight on each unit is the inverse probability of the treatment value that happened for that unit.\n\n$$\nw_i = \\begin{cases}\n\\frac{1}{\\text{P}(A = 1\\mid \\vec{X} = \\vec{x}_i)} &\\text{if treated} \\\\\n\\frac{1}{1 - \\text{P}(A = 1\\mid \\vec{X} = \\vec{x}_i)} &\\text{if untreated}\n\\end{cases}\n$$\n\nIn code, we can use `case_when()` to assign this weight as `1 / p_treated` for treated units and `1 / (1 - p_treated)` for untreated units.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninverse_probability_weights <- predicted_treatment_probabilities |>\n  mutate(\n    weight = case_when(\n      a == \"treated\" ~ 1 / p_treated,\n      a == \"untreated\" ~ 1 / (1 - p_treated)\n    )\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,688 x 5\n     id a         y     p_treated weight\n  <dbl> <chr>     <lgl>     <dbl>  <dbl>\n1     1 untreated FALSE    0.0720   1.08\n2     2 treated   TRUE     0.777    1.29\n3     3 untreated FALSE    0.0318   1.03\n# i 7,685 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### 3) Estimate by weighted means\n\nFinally, we use the weights to take the treated units and draw inference about what would happen to all units if they were hypothetically treated, and to use the untreated units and draw inference about what would happen to all units if they were hypothetically untreated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninverse_probability_weights |>\n  # Within each treatment group\n  group_by(a) |>\n  # Take the mean weighted by inverse probability of treatment weights\n  summarize(estimate = weighted.mean(y, w = weight)) |>\n  # Pivot wider and difference to estimate the effect\n  pivot_wider(names_from = a, values_from = estimate, names_prefix = \"if_\") |>\n  mutate(effect = if_treated - if_untreated)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  if_treated if_untreated effect\n       <dbl>        <dbl>  <dbl>\n1      0.382        0.166  0.217\n```\n\n\n:::\n:::\n\n\n\n\n## Concluding thoughts\n\nOutcome modeling is a powerful strategy because it bridges nonparametric causal identification to longstanding strategies where outcomes are modeled by parametric regression.\n\nInverse probability of treatment weighting is a powerful strategy because it bridges nonparametric causal identification to longstanding strategies from survey sampling where units from a population are sampled with known probabilities of inclusion. The analogy is that outcomes under treatment are sampled with estimated inclusion probabilities (the probability of treatment). Just as in a population sample we would need to think carefully about the probability of sampling, treatment modeling encourages us to model the probability of receiving the observed treatment.\n\n<!-- Doubly robust estimation brings the two together for an estimator that is statistically preferable, albeit conceptually more complicated! -->\n",
    "supporting": [
      "models_for_causal_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}